{"ast":null,"code":"import _objectSpread from \"C:/Users/User/speech-grammars/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport { send, assign } from \"xstate\"; // SRGS parser and example (logs the results to console on page load)\n\nimport { loadGrammar } from './runparser';\nimport { parse } from './chartparser';\nimport { grammar } from './grammars/chores';\nconst gram = loadGrammar(grammar);\nconst input = \"Please turn the light off\";\nconst prs = parse(input.split(/\\s+/), gram);\nconst result = prs.resultsForRule(gram.$root)[0];\nconsole.log(result);\n\nfunction say(text) {\n  return send(_context => ({\n    type: \"SPEAK\",\n    value: text\n  }));\n}\n\nfunction listen() {\n  return send('LISTEN');\n}\n\nfunction parsing(text) {\n  return parse(text.split(/\\s+/), gram).resultsForRule(gram.$root)[0];\n}\n\nfunction promptAndAsk(prompt) {\n  return {\n    initial: 'prompt',\n    states: {\n      prompt: {\n        entry: say(prompt),\n        on: {\n          ENDSPEECH: 'ask'\n        }\n      },\n      ask: {\n        entry: listen()\n      }\n    }\n  };\n}\n\nexport const dmMachine = {\n  initial: 'init',\n  states: {\n    init: {\n      on: {\n        CLICK: 'welcome'\n      }\n    },\n    welcome: _objectSpread({\n      on: {\n        RECOGNISED: [{\n          cond: context => parsing(context.recResult) !== undefined,\n          target: \"returntheobject\",\n          actions: assign(context => {\n            return {\n              option: parsing(context.recResult)\n            };\n          })\n        }, {\n          target: \".nomatch\"\n        }]\n      }\n    }, promptAndAsk(\"What do you want to do?\")),\n    returnobject: {\n      initial: \"prompt\",\n      on: {\n        ENDSPEECH: \"init\"\n      },\n      states: {\n        prompt: {\n          entry: send(context => ({\n            type: \"SPEAK\",\n            value: \"OK. the object is \".concat(context.option.homeappliances.object, \" and the action is \").concat(context.option.homeappliances.action, \".\")\n          }))\n        }\n      }\n    }\n  }\n};","map":{"version":3,"sources":["C:/Users/User/speech-grammars/src/dmSmartHome.ts"],"names":["send","assign","loadGrammar","parse","grammar","gram","input","prs","split","result","resultsForRule","$root","console","log","say","text","_context","type","value","listen","parsing","promptAndAsk","prompt","initial","states","entry","on","ENDSPEECH","ask","dmMachine","init","CLICK","welcome","RECOGNISED","cond","context","recResult","undefined","target","actions","option","returnobject","homeappliances","object","action"],"mappings":"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","sourcesContent":["import { MachineConfig, send, Action, assign } from \"xstate\";\n\n// SRGS parser and example (logs the results to console on page load)\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/chores'\n\nconst gram = loadGrammar(grammar)\nconst input = \"Please turn the light off\"\nconst prs = parse(input.split(/\\s+/), gram)\nconst result = prs.resultsForRule(gram.$root)[0]\nconsole.log(result)\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\nfunction parsing(text:string): MachineConfig<SDSContext, any, SDSEvent> {\n    return (parse(text.split(/\\s+/), gram).resultsForRule(gram.$root)[0])\n}\n\nfunction promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: listen(),\n            },\n        }\n    })\n}\n\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'init',\n    states: {\n        init: {\n            on: {\n                CLICK: 'welcome'\n            }\n        },\n        welcome: {\n            on: {\n                RECOGNISED: [{\n                    cond: (context) => parsing(context.recResult) !== undefined,\n                    target: \"returntheobject\",\n                    actions: assign((context) => { return { option: parsing(context.recResult) } }),\n                },\n                {target: \".nomatch\" }]    \n            },\n                ...promptAndAsk(\"What do you want to do?\")\n        },\n        returnobject: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"init\" },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. the object is ${context.option.homeappliances.object} and the action is ${context.option.homeappliances.action}.`\n                    }))\n                },\n            }\n        },\n        \n    }\n})\n"]},"metadata":{},"sourceType":"module"}
{"ast":null,"code":"//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/ /* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/ //////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str){//console.log(\"\" + str);\n}import*as SRGS from'./srgs';//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){if(obj==null||typeof obj!='object'){return obj;}var temp=new obj.constructor();for(var key in obj){temp[key]=clone(obj[key]);}return temp;}function isEmpty(ob){for(var i in ob){if(ob.hasOwnProperty(i)){return false;}}return true;}//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords){this.numberOfWords=numberOfWords;this.passives=new Array(numberOfWords);this.actives=new Array(numberOfWords);for(var i=0;i<=numberOfWords;i++){this.passives[i]={};this.actives[i]={};}// Chart.add(edge)\n// add the edge to the chart, return true if the chart was changed \n// (i.e. if the chart didn't already contain the edge)\nthis.add=function add(edge){var subchart,cat;if(edge.isPassive){subchart=this.passives[edge.start];cat=edge.lhs;}else{subchart=this.actives[edge.end];cat=edge.next.content;}if(!(cat in subchart)){subchart[cat]={};}if(edge in subchart[cat]){return false;}else{subchart[cat][edge]=edge;return true;}};// Chart.resultsForRule(lhs, start, end)\n// return all parse results for the given lhs, start, and end\n//  - start, end are optional; defaults to 0, numberOfWords\nthis.resultsForRule=function resultsForRule(lhs,start,end){start=start||0;end=end||numberOfWords;var results=[];var finalEdges=this.passives[start][lhs];for(var i in finalEdges){if(finalEdges[i].end==end){results.push(finalEdges[i].out);}}return results;};// Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n// return an array of all (passive/active) edges in the chart\nthis.allEdges=function allEdges(){return this.allPassiveEdges().concat(this.allActiveEdges());};this.allPassiveEdges=function allPassiveEdges(){var edges=[];for(var i in this.passives)for(var j in this.passives[i])for(var k in this.passives[i][j])edges.push(this.passives[i][j][k]);return edges;};this.allActiveEdges=function allActiveEdges(){var edges=[];for(var i in this.actives)for(var j in this.actives[i])for(var k in this.actives[i][j])edges.push(this.actives[i][j][k]);return edges;};// Chart.statistics()\n// return the number of edges in the chart\nthis.statistics=function statistics(){var passives=this.allPassiveEdges().length;var actives=this.allActiveEdges().length;return{nrEdges:passives+actives,nrPassiveEdges:passives,nrActiveEdges:actives};};}//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\nfunction PassiveEdge(start,end,lhs,out){this.start=start;this.end=end;this.lhs=lhs;this.out=out;this.isPassive=true;var str=\"[\"+start+\"-\"+end+\"] $\"+lhs+\" := \"+out;this._string=str;this.toString=function toString(){return this._string;};}function ActiveEdge(start,end,lhs,next,rest,out,rules,text){this.start=start;this.end=end;this.lhs=lhs;this.next=next;this.rest=rest;this.out=out;this.rules=rules;this.text=text;this.isPassive=false;var str=\"<\"+start+\"-\"+end+\"> $\"+lhs+\" -> \"+next+\", \"+rest+\" := \"+out+\" <- \"+rules;this._string=str;this.toString=function toString(){return this._string;};}//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words,grammar,root,filter){if(!root){root=grammar.$root;}var chart=new Chart(words.length);var agenda=[];var leftCornerFilter;if(filter==undefined){leftCornerFilter=function leftCornerFilter(){return true;};}else{leftCornerFilter=function leftCornerFilter(ruleref,position){var leftCorners=filter[ruleref];return leftCorners?words[position]in leftCorners:true;};}// add an edge to the chart and the agenda, if it does not already exist\nfunction addToChart(inference,start,end,lhs,rhs,out,rules,text){var edge;if(rhs.length>0){var next=rhs[0];var rest=rhs.slice(1);switch(next.constructor){case Array:// the next symbol is a sequence\naddToChart(inference+\",SEQUENCE\",start,end,lhs,next.concat(rest),out,rules,text);return;case SRGS.RepeatClass:// the next symbol is a repetition\nvar min=next.min;var max=next.max;// skip repeat \nif(min<=0){addToChart(inference+\",SKIP\",start,end,lhs,rest,out,rules,text);}// repeat \nif(max>0){var content=next.content;var rhs=max==1?[content]:[content,SRGS.Repeat(min?min-1:min,max-1,content)];addToChart(inference+\",REPEAT\",start,end,lhs,rhs.concat(rest),out,rules,text);}return;case SRGS.OneOfClass:// the next symbol is a disjunction\nvar oneof=next.content;for(var i in oneof){var rhs=oneof[i].concat(rest);addToChart(inference+\",ONEOF\",start,end,lhs,rhs,out,rules,text);}return;case SRGS.TagClass:// the next symbol is a semantic action\nout=clone(out);rules=clone(rules);eval(next.content);addToChart(inference+\",TAG\",start,end,lhs,rest,out,rules,text);return;}edge=new ActiveEdge(start,end,lhs,next,rest,out,rules,text);}else{edge=new PassiveEdge(start,end,lhs,out);}// try to add the edge; if successful, also add it to the agenda\nif(chart.add(edge)){LOG(\"+ \"+inference+\": \"+edge);agenda.push(edge);}}// seed the agenda with the starting rule\naddToChart(\"INIT\",0,0,root,grammar[root],{},{},{});// main loop\nwhile(agenda.length>0){var edge=agenda.pop();var start=edge.start;var end=edge.end;var lhs=edge.lhs;var next=edge.next;LOG(edge);if(edge.isPassive){// combine\nvar actives=chart.actives[start][lhs];for(var i in actives){var active=actives[i];var rules=clone(active.rules);var text=active.text;text[edge.lhs]=words.slice(start,end).join(\" \");if(typeof edge.out=='object'&&isEmpty(edge.out)){rules[edge.lhs]=text[edge.lhs];}else{rules[edge.lhs]=clone(edge.out);}addToChart(\"COMBINE\",active.start,end,active.lhs,active.rest,active.out,rules,text);}}else if(next.constructor==SRGS.RefClass){var ref=next.content;// combine\nvar passives=chart.passives[end][ref];for(var i in passives){var passive=passives[i];var rules=clone(edge.rules);var text=edge.text;rules[passive.lhs]=clone(passive.out);text[passive.lhs]=passive.text;addToChart(\"COMBINE\",start,passive.end,lhs,edge.rest,edge.out,rules,text);}// predict\nif(ref in grammar){if(leftCornerFilter(ref,end)){addToChart(\"PREDICT\",end,end,ref,grammar[ref],{},{},{});}}}else if(next==words[end]){// scan\naddToChart(\"SCAN\",start,end+1,lhs,edge.rest,edge.out,edge.rules,edge.text);}}return chart;}","map":{"version":3,"sources":["C:/Users/User/speech-grammars/src/chartparser.js"],"names":["LOG","str","SRGS","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","undefined","ruleref","position","leftCorners","addToChart","inference","rhs","slice","RepeatClass","min","max","Repeat","OneOfClass","oneof","TagClass","eval","pop","active","join","RefClass","ref","passive"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E,CAEA;AACA;AACA;AACA,E,CAEA;AACA;AACA;AACA,QAASA,CAAAA,GAAT,CAAaC,GAAb,CAAkB,CAChB;AACD,CAED,MAAO,GAAKC,CAAAA,IAAZ,KAAsB,QAAtB,CAEA;AACA;AACA;AACA,QAASC,CAAAA,KAAT,CAAeC,GAAf,CAAmB,CACjB,GAAIA,GAAG,EAAI,IAAP,EAAe,MAAOA,CAAAA,GAAP,EAAe,QAAlC,CAA4C,CAC1C,MAAOA,CAAAA,GAAP,CACD,CACD,GAAIC,CAAAA,IAAI,CAAG,GAAID,CAAAA,GAAG,CAACE,WAAR,EAAX,CACA,IAAK,GAAIC,CAAAA,GAAT,GAAgBH,CAAAA,GAAhB,CAAqB,CACnBC,IAAI,CAACE,GAAD,CAAJ,CAAYJ,KAAK,CAACC,GAAG,CAACG,GAAD,CAAJ,CAAjB,CACD,CACD,MAAOF,CAAAA,IAAP,CACD,CAGD,QAASG,CAAAA,OAAT,CAAiBC,EAAjB,CAAoB,CACjB,IAAK,GAAIC,CAAAA,CAAT,GAAcD,CAAAA,EAAd,CAAkB,CAAE,GAAGA,EAAE,CAACE,cAAH,CAAkBD,CAAlB,CAAH,CAAyB,CAAC,MAAO,MAAP,CAAc,CAAC,CAC9D,MAAO,KAAP,CACD,CAED;AACA;AACA;AACA,QAASE,CAAAA,KAAT,CAAeC,aAAf,CAA8B,CAC5B,KAAKA,aAAL,CAAqBA,aAArB,CACA,KAAKC,QAAL,CAAgB,GAAIC,CAAAA,KAAJ,CAAUF,aAAV,CAAhB,CACA,KAAKG,OAAL,CAAe,GAAID,CAAAA,KAAJ,CAAUF,aAAV,CAAf,CACA,IAAK,GAAIH,CAAAA,CAAC,CAAG,CAAb,CAAgBA,CAAC,EAAIG,aAArB,CAAoCH,CAAC,EAArC,CAAyC,CACvC,KAAKI,QAAL,CAAcJ,CAAd,EAAmB,EAAnB,CACA,KAAKM,OAAL,CAAaN,CAAb,EAAkB,EAAlB,CACD,CAED;AACA;AACA;AACA,KAAKO,GAAL,CAAW,QAASA,CAAAA,GAAT,CAAaC,IAAb,CAAmB,CAC5B,GAAIC,CAAAA,QAAJ,CAAcC,GAAd,CACA,GAAIF,IAAI,CAACG,SAAT,CAAoB,CAClBF,QAAQ,CAAG,KAAKL,QAAL,CAAcI,IAAI,CAACI,KAAnB,CAAX,CACAF,GAAG,CAAGF,IAAI,CAACK,GAAX,CACD,CAHD,IAGO,CACLJ,QAAQ,CAAG,KAAKH,OAAL,CAAaE,IAAI,CAACM,GAAlB,CAAX,CACAJ,GAAG,CAAGF,IAAI,CAACO,IAAL,CAAUC,OAAhB,CACD,CACD,GAAI,EAAEN,GAAG,GAAID,CAAAA,QAAT,CAAJ,CAAwB,CACtBA,QAAQ,CAACC,GAAD,CAAR,CAAgB,EAAhB,CACD,CACD,GAAIF,IAAI,GAAIC,CAAAA,QAAQ,CAACC,GAAD,CAApB,CAA2B,CACzB,MAAO,MAAP,CACD,CAFD,IAEO,CACLD,QAAQ,CAACC,GAAD,CAAR,CAAcF,IAAd,EAAsBA,IAAtB,CACA,MAAO,KAAP,CACD,CACF,CAlBD,CAoBA;AACA;AACA;AACA,KAAKS,cAAL,CAAsB,QAASA,CAAAA,cAAT,CAAwBJ,GAAxB,CAA6BD,KAA7B,CAAoCE,GAApC,CAAyC,CAC7DF,KAAK,CAAGA,KAAK,EAAI,CAAjB,CACAE,GAAG,CAAGA,GAAG,EAAIX,aAAb,CACA,GAAIe,CAAAA,OAAO,CAAG,EAAd,CACA,GAAIC,CAAAA,UAAU,CAAG,KAAKf,QAAL,CAAcQ,KAAd,EAAqBC,GAArB,CAAjB,CACA,IAAK,GAAIb,CAAAA,CAAT,GAAcmB,CAAAA,UAAd,CAA0B,CACxB,GAAIA,UAAU,CAACnB,CAAD,CAAV,CAAcc,GAAd,EAAqBA,GAAzB,CAA8B,CACnCI,OAAO,CAACE,IAAR,CAAaD,UAAU,CAACnB,CAAD,CAAV,CAAcqB,GAA3B,EACM,CACF,CACD,MAAOH,CAAAA,OAAP,CACD,CAXD,CAaA;AACA;AACA,KAAKI,QAAL,CAAgB,QAASA,CAAAA,QAAT,EAAoB,CAClC,MAAO,MAAKC,eAAL,GAAuBC,MAAvB,CAA8B,KAAKC,cAAL,EAA9B,CAAP,CACD,CAFD,CAGA,KAAKF,eAAL,CAAuB,QAASA,CAAAA,eAAT,EAA2B,CAChD,GAAIG,CAAAA,KAAK,CAAG,EAAZ,CACA,IAAK,GAAI1B,CAAAA,CAAT,GAAc,MAAKI,QAAnB,CACE,IAAK,GAAIuB,CAAAA,CAAT,GAAc,MAAKvB,QAAL,CAAcJ,CAAd,CAAd,CACL,IAAK,GAAI4B,CAAAA,CAAT,GAAc,MAAKxB,QAAL,CAAcJ,CAAd,EAAiB2B,CAAjB,CAAd,CACED,KAAK,CAACN,IAAN,CAAW,KAAKhB,QAAL,CAAcJ,CAAd,EAAiB2B,CAAjB,EAAoBC,CAApB,CAAX,EACC,MAAOF,CAAAA,KAAP,CACD,CAPD,CAQA,KAAKD,cAAL,CAAsB,QAASA,CAAAA,cAAT,EAA0B,CAC9C,GAAIC,CAAAA,KAAK,CAAG,EAAZ,CACA,IAAK,GAAI1B,CAAAA,CAAT,GAAc,MAAKM,OAAnB,CACE,IAAK,GAAIqB,CAAAA,CAAT,GAAc,MAAKrB,OAAL,CAAaN,CAAb,CAAd,CACL,IAAK,GAAI4B,CAAAA,CAAT,GAAc,MAAKtB,OAAL,CAAaN,CAAb,EAAgB2B,CAAhB,CAAd,CACED,KAAK,CAACN,IAAN,CAAW,KAAKd,OAAL,CAAaN,CAAb,EAAgB2B,CAAhB,EAAmBC,CAAnB,CAAX,EACC,MAAOF,CAAAA,KAAP,CACD,CAPD,CASA;AACA;AACA,KAAKG,UAAL,CAAkB,QAASA,CAAAA,UAAT,EAAsB,CACtC,GAAIzB,CAAAA,QAAQ,CAAG,KAAKmB,eAAL,GAAuBO,MAAtC,CACA,GAAIxB,CAAAA,OAAO,CAAG,KAAKmB,cAAL,GAAsBK,MAApC,CACA,MAAO,CAACC,OAAO,CAAE3B,QAAQ,CAACE,OAAnB,CAA4B0B,cAAc,CAAE5B,QAA5C,CAAsD6B,aAAa,CAAE3B,OAArE,CAAP,CACD,CAJD,CAKD,CAGD;AACA;AAEA,QAAS4B,CAAAA,WAAT,CAAqBtB,KAArB,CAA4BE,GAA5B,CAAiCD,GAAjC,CAAsCQ,GAAtC,CAA2C,CACzC,KAAKT,KAAL,CAAaA,KAAb,CACA,KAAKE,GAAL,CAAWA,GAAX,CACA,KAAKD,GAAL,CAAWA,GAAX,CACA,KAAKQ,GAAL,CAAWA,GAAX,CACA,KAAKV,SAAL,CAAiB,IAAjB,CAEA,GAAIpB,CAAAA,GAAG,CAAG,IAAMqB,KAAN,CAAc,GAAd,CAAoBE,GAApB,CAA0B,KAA1B,CAAkCD,GAAlC,CAAwC,MAAxC,CAAiDQ,GAA3D,CACA,KAAKc,OAAL,CAAe5C,GAAf,CACA,KAAK6C,QAAL,CAAgB,QAASA,CAAAA,QAAT,EAAoB,CAAC,MAAO,MAAKD,OAAZ,CAAqB,CAA1D,CACD,CAED,QAASE,CAAAA,UAAT,CAAoBzB,KAApB,CAA2BE,GAA3B,CAAgCD,GAAhC,CAAqCE,IAArC,CAA2CuB,IAA3C,CAAiDjB,GAAjD,CAAsDkB,KAAtD,CAA6DC,IAA7D,CAAmE,CACjE,KAAK5B,KAAL,CAAaA,KAAb,CACA,KAAKE,GAAL,CAAWA,GAAX,CACA,KAAKD,GAAL,CAAWA,GAAX,CACA,KAAKE,IAAL,CAAYA,IAAZ,CACA,KAAKuB,IAAL,CAAYA,IAAZ,CACA,KAAKjB,GAAL,CAAWA,GAAX,CACA,KAAKkB,KAAL,CAAaA,KAAb,CACA,KAAKC,IAAL,CAAYA,IAAZ,CACA,KAAK7B,SAAL,CAAiB,KAAjB,CAEA,GAAIpB,CAAAA,GAAG,CAAG,IAAMqB,KAAN,CAAc,GAAd,CAAoBE,GAApB,CAA0B,KAA1B,CAAkCD,GAAlC,CAAwC,MAAxC,CAAiDE,IAAjD,CACR,IADQ,CACDuB,IADC,CACM,MADN,CACejB,GADf,CACqB,MADrB,CAC8BkB,KADxC,CAEA,KAAKJ,OAAL,CAAe5C,GAAf,CACA,KAAK6C,QAAL,CAAgB,QAASA,CAAAA,QAAT,EAAoB,CAAC,MAAO,MAAKD,OAAZ,CAAqB,CAA1D,CACD,CAGD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAO,SAASM,CAAAA,KAAT,CAAeC,KAAf,CAAsBC,OAAtB,CAA+BC,IAA/B,CAAqCC,MAArC,CAA6C,CAClD,GAAI,CAACD,IAAL,CAAW,CACTA,IAAI,CAAGD,OAAO,CAACG,KAAf,CACD,CACD,GAAIC,CAAAA,KAAK,CAAG,GAAI7C,CAAAA,KAAJ,CAAUwC,KAAK,CAACZ,MAAhB,CAAZ,CACA,GAAIkB,CAAAA,MAAM,CAAG,EAAb,CAEA,GAAIC,CAAAA,gBAAJ,CACA,GAAIJ,MAAM,EAAIK,SAAd,CAAyB,CACvBD,gBAAgB,CAAG,2BAAW,CAAC,MAAO,KAAP,CAAY,CAA3C,CACD,CAFD,IAEO,CACLA,gBAAgB,CAAG,QAASA,CAAAA,gBAAT,CAA0BE,OAA1B,CAAmCC,QAAnC,CAA6C,CAC9D,GAAIC,CAAAA,WAAW,CAAGR,MAAM,CAACM,OAAD,CAAxB,CACA,MAAOE,CAAAA,WAAW,CAAGX,KAAK,CAACU,QAAD,CAAL,EAAmBC,CAAAA,WAAtB,CAAoC,IAAtD,CACD,CAHD,CAID,CAED;AACA,QAASC,CAAAA,UAAT,CAAoBC,SAApB,CAA+B3C,KAA/B,CAAsCE,GAAtC,CAA2CD,GAA3C,CAAgD2C,GAAhD,CAAqDnC,GAArD,CAA0DkB,KAA1D,CAAiEC,IAAjE,CAAuE,CACrE,GAAIhC,CAAAA,IAAJ,CACA,GAAIgD,GAAG,CAAC1B,MAAJ,CAAa,CAAjB,CAAoB,CAClB,GAAIf,CAAAA,IAAI,CAAGyC,GAAG,CAAC,CAAD,CAAd,CACA,GAAIlB,CAAAA,IAAI,CAAGkB,GAAG,CAACC,KAAJ,CAAU,CAAV,CAAX,CACA,OAAQ1C,IAAI,CAACnB,WAAb,EAEA,IAAKS,CAAAA,KAAL,CACL;AACAiD,UAAU,CAACC,SAAS,CAAC,WAAX,CAAwB3C,KAAxB,CAA+BE,GAA/B,CAAoCD,GAApC,CAAyCE,IAAI,CAACS,MAAL,CAAYc,IAAZ,CAAzC,CAA4DjB,GAA5D,CAAiEkB,KAAjE,CAAwEC,IAAxE,CAAV,CACA,OAEK,IAAKhD,CAAAA,IAAI,CAACkE,WAAV,CACL;AACA,GAAIC,CAAAA,GAAG,CAAG5C,IAAI,CAAC4C,GAAf,CACA,GAAIC,CAAAA,GAAG,CAAG7C,IAAI,CAAC6C,GAAf,CACA;AACA,GAAID,GAAG,EAAI,CAAX,CAAc,CACZL,UAAU,CAACC,SAAS,CAAC,OAAX,CAAoB3C,KAApB,CAA2BE,GAA3B,CAAgCD,GAAhC,CAAqCyB,IAArC,CAA2CjB,GAA3C,CAAgDkB,KAAhD,CAAuDC,IAAvD,CAAV,CACD,CACD;AACA,GAAIoB,GAAG,CAAG,CAAV,CAAa,CACX,GAAI5C,CAAAA,OAAO,CAAGD,IAAI,CAACC,OAAnB,CACA,GAAIwC,CAAAA,GAAG,CAAII,GAAG,EAAE,CAAL,CAAS,CAAC5C,OAAD,CAAT,CAAqB,CAACA,OAAD,CAAUxB,IAAI,CAACqE,MAAL,CAAYF,GAAG,CAAGA,GAAG,CAAC,CAAP,CAAWA,GAA1B,CAA+BC,GAAG,CAAC,CAAnC,CAAsC5C,OAAtC,CAAV,CAAhC,CACAsC,UAAU,CAACC,SAAS,CAAC,SAAX,CAAsB3C,KAAtB,CAA6BE,GAA7B,CAAkCD,GAAlC,CAAuC2C,GAAG,CAAChC,MAAJ,CAAWc,IAAX,CAAvC,CAAyDjB,GAAzD,CAA8DkB,KAA9D,CAAqEC,IAArE,CAAV,CACD,CACD,OAEK,IAAKhD,CAAAA,IAAI,CAACsE,UAAV,CACL;AACA,GAAIC,CAAAA,KAAK,CAAGhD,IAAI,CAACC,OAAjB,CACA,IAAK,GAAIhB,CAAAA,CAAT,GAAc+D,CAAAA,KAAd,CAAqB,CACnB,GAAIP,CAAAA,GAAG,CAAGO,KAAK,CAAC/D,CAAD,CAAL,CAASwB,MAAT,CAAgBc,IAAhB,CAAV,CACAgB,UAAU,CAACC,SAAS,CAAC,QAAX,CAAqB3C,KAArB,CAA4BE,GAA5B,CAAiCD,GAAjC,CAAsC2C,GAAtC,CAA2CnC,GAA3C,CAAgDkB,KAAhD,CAAuDC,IAAvD,CAAV,CACD,CACD,OAEK,IAAKhD,CAAAA,IAAI,CAACwE,QAAV,CACL;AACA3C,GAAG,CAAG5B,KAAK,CAAC4B,GAAD,CAAX,CACAkB,KAAK,CAAG9C,KAAK,CAAC8C,KAAD,CAAb,CACA0B,IAAI,CAAClD,IAAI,CAACC,OAAN,CAAJ,CACAsC,UAAU,CAACC,SAAS,CAAC,MAAX,CAAmB3C,KAAnB,CAA0BE,GAA1B,CAA+BD,GAA/B,CAAoCyB,IAApC,CAA0CjB,GAA1C,CAA+CkB,KAA/C,CAAsDC,IAAtD,CAAV,CACA,OAtCK,CAyCAhC,IAAI,CAAG,GAAI6B,CAAAA,UAAJ,CAAezB,KAAf,CAAsBE,GAAtB,CAA2BD,GAA3B,CAAgCE,IAAhC,CAAsCuB,IAAtC,CAA4CjB,GAA5C,CAAiDkB,KAAjD,CAAwDC,IAAxD,CAAP,CACD,CA7CD,IA6CO,CACLhC,IAAI,CAAG,GAAI0B,CAAAA,WAAJ,CAAgBtB,KAAhB,CAAuBE,GAAvB,CAA4BD,GAA5B,CAAiCQ,GAAjC,CAAP,CACD,CAED;AACA,GAAI0B,KAAK,CAACxC,GAAN,CAAUC,IAAV,CAAJ,CAAqB,CACnBlB,GAAG,CAAC,KAAOiE,SAAP,CAAmB,IAAnB,CAA0B/C,IAA3B,CAAH,CACAwC,MAAM,CAAC5B,IAAP,CAAYZ,IAAZ,EACD,CACF,CAED;AACA8C,UAAU,CAAC,MAAD,CAAS,CAAT,CAAY,CAAZ,CAAeV,IAAf,CAAqBD,OAAO,CAACC,IAAD,CAA5B,CAAoC,EAApC,CAAwC,EAAxC,CAA4C,EAA5C,CAAV,CAEA;AACA,MAAOI,MAAM,CAAClB,MAAP,CAAgB,CAAvB,CAA0B,CACxB,GAAItB,CAAAA,IAAI,CAAGwC,MAAM,CAACkB,GAAP,EAAX,CACA,GAAItD,CAAAA,KAAK,CAAEJ,IAAI,CAACI,KAAhB,CACA,GAAIE,CAAAA,GAAG,CAAIN,IAAI,CAACM,GAAhB,CACA,GAAID,CAAAA,GAAG,CAAIL,IAAI,CAACK,GAAhB,CACA,GAAIE,CAAAA,IAAI,CAAGP,IAAI,CAACO,IAAhB,CACAzB,GAAG,CAACkB,IAAD,CAAH,CAEA,GAAIA,IAAI,CAACG,SAAT,CAAoB,CAClB;AACA,GAAIL,CAAAA,OAAO,CAAGyC,KAAK,CAACzC,OAAN,CAAcM,KAAd,EAAqBC,GAArB,CAAd,CACA,IAAK,GAAIb,CAAAA,CAAT,GAAcM,CAAAA,OAAd,CAAuB,CAC5B,GAAI6D,CAAAA,MAAM,CAAG7D,OAAO,CAACN,CAAD,CAApB,CACA,GAAIuC,CAAAA,KAAK,CAAG9C,KAAK,CAAC0E,MAAM,CAAC5B,KAAR,CAAjB,CACA,GAAIC,CAAAA,IAAI,CAAG2B,MAAM,CAAC3B,IAAlB,CACAA,IAAI,CAAChC,IAAI,CAACK,GAAN,CAAJ,CAAiB6B,KAAK,CAACe,KAAN,CAAY7C,KAAZ,CAAmBE,GAAnB,EAAwBsD,IAAxB,CAA6B,GAA7B,CAAjB,CACA,GAAI,MAAO5D,CAAAA,IAAI,CAACa,GAAZ,EAAmB,QAAnB,EAA+BvB,OAAO,CAACU,IAAI,CAACa,GAAN,CAA1C,CAAsD,CAClDkB,KAAK,CAAC/B,IAAI,CAACK,GAAN,CAAL,CAAkB2B,IAAI,CAAChC,IAAI,CAACK,GAAN,CAAtB,CACH,CAFD,IAEO,CACA0B,KAAK,CAAC/B,IAAI,CAACK,GAAN,CAAL,CAAkBpB,KAAK,CAACe,IAAI,CAACa,GAAN,CAAvB,CACH,CACJiC,UAAU,CAAC,SAAD,CAAYa,MAAM,CAACvD,KAAnB,CAA0BE,GAA1B,CAA+BqD,MAAM,CAACtD,GAAtC,CAA2CsD,MAAM,CAAC7B,IAAlD,CAAwD6B,MAAM,CAAC9C,GAA/D,CAAoEkB,KAApE,CAA2EC,IAA3E,CAAV,CACM,CAEF,CAhBD,IAgBO,IAAIzB,IAAI,CAACnB,WAAL,EAAoBJ,IAAI,CAAC6E,QAA7B,CAAuC,CAC5C,GAAIC,CAAAA,GAAG,CAAGvD,IAAI,CAACC,OAAf,CACA;AACA,GAAIZ,CAAAA,QAAQ,CAAG2C,KAAK,CAAC3C,QAAN,CAAeU,GAAf,EAAoBwD,GAApB,CAAf,CACA,IAAK,GAAItE,CAAAA,CAAT,GAAcI,CAAAA,QAAd,CAAwB,CAC7B,GAAImE,CAAAA,OAAO,CAAGnE,QAAQ,CAACJ,CAAD,CAAtB,CACA,GAAIuC,CAAAA,KAAK,CAAG9C,KAAK,CAACe,IAAI,CAAC+B,KAAN,CAAjB,CACA,GAAIC,CAAAA,IAAI,CAAGhC,IAAI,CAACgC,IAAhB,CACAD,KAAK,CAACgC,OAAO,CAAC1D,GAAT,CAAL,CAAqBpB,KAAK,CAAC8E,OAAO,CAAClD,GAAT,CAA1B,CACAmB,IAAI,CAAC+B,OAAO,CAAC1D,GAAT,CAAJ,CAAoB0D,OAAO,CAAC/B,IAA5B,CACAc,UAAU,CAAC,SAAD,CAAY1C,KAAZ,CAAmB2D,OAAO,CAACzD,GAA3B,CAAgCD,GAAhC,CAAqCL,IAAI,CAAC8B,IAA1C,CAAgD9B,IAAI,CAACa,GAArD,CAA0DkB,KAA1D,CAAiEC,IAAjE,CAAV,CACM,CACD;AACA,GAAI8B,GAAG,GAAI3B,CAAAA,OAAX,CAAoB,CACzB,GAAIM,gBAAgB,CAACqB,GAAD,CAAMxD,GAAN,CAApB,CAAgC,CAC9BwC,UAAU,CAAC,SAAD,CAAYxC,GAAZ,CAAiBA,GAAjB,CAAsBwD,GAAtB,CAA2B3B,OAAO,CAAC2B,GAAD,CAAlC,CAAyC,EAAzC,CAA6C,EAA7C,CAAiD,EAAjD,CAAV,CACD,CACK,CAEF,CAnBM,IAmBA,IAAIvD,IAAI,EAAI2B,KAAK,CAAC5B,GAAD,CAAjB,CAAwB,CAC7B;AACAwC,UAAU,CAAC,MAAD,CAAS1C,KAAT,CAAgBE,GAAG,CAAC,CAApB,CAAuBD,GAAvB,CAA4BL,IAAI,CAAC8B,IAAjC,CAAuC9B,IAAI,CAACa,GAA5C,CAAiDb,IAAI,CAAC+B,KAAtD,CAA6D/B,IAAI,CAACgC,IAAlE,CAAV,CACD,CACF,CAED,MAAOO,CAAAA,KAAP,CACD","sourcesContent":["//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n  //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){\n  if (obj == null || typeof(obj) != 'object') {\n    return obj;\n  }\n  var temp = new obj.constructor(); \n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n  return temp;\n}\n\n\nfunction isEmpty(ob){\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  }\n\n  // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n  this.add = function add(edge) {\n    var subchart, cat;\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }\n\n  // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n\tresults.push(finalEdges[i].out);\n      }\n    }\n    return results;\n  }\n  \n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  }\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n    for (var i in this.passives) \n      for (var j in this.passives[i]) \n\tfor (var k in this.passives[i][j])\n\t  edges.push(this.passives[i][j][k]);\n    return edges;\n  }\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n    for (var i in this.actives) \n      for (var j in this.actives[i]) \n\tfor (var k in this.actives[i][j])\n\t  edges.push(this.actives[i][j][k]);\n    return edges;\n  }\n\n  // Chart.statistics()\n  // return the number of edges in the chart\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \n    \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n  var chart = new Chart(words.length);\n  var agenda = [];\n\n  var leftCornerFilter;\n  if (filter == undefined) {\n    leftCornerFilter = function() {return true};\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    }\n  }\n  \n  // add an edge to the chart and the agenda, if it does not already exist\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n      switch (next.constructor) {\n\t\n      case Array:\n\t// the next symbol is a sequence\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n\treturn;\n\t\n      case SRGS.RepeatClass:\n\t// the next symbol is a repetition\n\tvar min = next.min;\n\tvar max = next.max;\n\t// skip repeat \n\tif (min <= 0) {\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\n\t}\n\t// repeat \n\tif (max > 0) {\n\t  var content = next.content;\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n\t}\n\treturn;\n\t\n      case SRGS.OneOfClass:\n\t// the next symbol is a disjunction\n\tvar oneof = next.content;\n\tfor (var i in oneof) {\n\t  var rhs = oneof[i].concat(rest);\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\n\t} \n\treturn;\n\t\n      case SRGS.TagClass:\n\t// the next symbol is a semantic action\n\tout = clone(out);\n\trules = clone(rules);\n\teval(next.content);\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\n\treturn;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    }\n    \n    // try to add the edge; if successful, also add it to the agenda\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  }\n  \n  // seed the agenda with the starting rule\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n  \n  // main loop\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start= edge.start;\n    var end  = edge.end;\n    var lhs  = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n      for (var i in actives) {\n\tvar active = actives[i];\n\tvar rules = clone(active.rules);\n\tvar text = active.text;\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\n\t    rules[edge.lhs] = text[edge.lhs];\n\t} else {\n        rules[edge.lhs] = clone(edge.out);\n    }\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content;\n      // combine\n      var passives = chart.passives[end][ref];\n      for (var i in passives) {\n\tvar passive = passives[i];\n\tvar rules = clone(edge.rules);\n\tvar text = edge.text;\n\trules[passive.lhs] = clone(passive.out);\n\ttext[passive.lhs] = passive.text;\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      }\n      // predict\n      if (ref in grammar) {\n\tif (leftCornerFilter(ref, end)) {\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n\t}\n      }\n\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n\n\n"]},"metadata":{},"sourceType":"module"}